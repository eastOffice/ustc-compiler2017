# Lab1-1 Report

PB15111610 张一卓

## 实验目标

根据C1语言的词法描述，修改并完善课程实验软件包中 C1 的词法描述文件；

利用所学的ANTLR的使用方法编译并测试分析器；

编写若干个正确的和错误的C1程序作为测试程序，来测试你所构造的C1 词法分析器。

## 实验分析与设计

首先，需要完善C1语言的词法描述文件。文件中已经定义好了所需要的所有tokens，所以只要先为所有的tokens写好词法定义，然后加上行注释和区块注释的定义即可。根据antler lexer的语法，定义tokens只要这样写：

```sh
Comma: ','; // 符号
Int: 'int'; // 关键字
Identifier: [a-zA-Z_] [a-zA-Z0-9_]*; // 标识符
```

需要注意的是，关键字要在标识符之前定义。

接下来就是注释的定义，对于区块注释，就是以 `/*`开头，到第一个`*/`结束的区域，中间可以匹配任意的字符。

```sh
BlockComment: '/*' .*? '*/' -> skip;
```

对于行注释，就是为`//`开始，到第一个行尾字符非`\`的行结束的区域。也就是说，如果遇到了行注释的开头`//`，但是这一行的结尾是`\`，那么下一行依然是注释。我是这么写的：

```sh
LineComment: ('//''\r'?'\n'|'//'.*? ~'\\''\r'?'\n') -> skip;
```

分为两种情况，如果行注释非空，那么行注释的结尾一定是一个非`\`的字符，前面可以匹配任意字符；如果行注释是空的，那么就是`//`作为行尾。注意不能漏掉第二种情况，因为前一种情况中，非`\`的字符一定会占用一个字符位，这是我在测试的时候发现的。

补充：空注释的情况一定要写在前面！！不然的话空注释有可能会匹配到第一种情况，把第二行匹配到`.*`中去！

另外，助教提醒我们要特别注意CRLF 和 LF 两种换行，所以换行的标准就是写成`'\r'? '\n'`。

## 测试

我编写了三个测试文件，test1-3，第一个文件用来测试C1语言的运算符，关键字，标识符，第二个文件用来测试正确的区块注释和行注释，第三个文件用来测试错误的注释。

test1.c1:

```c
void main()
{
    const k = 10;
    int i = 1
    if j != i
        j = i + 1
    else if j == i
        i - 1
    while j < 5 
        i * 5
        i % 10
     _hex = 0x12
}
```

测试结果：

```sh
[@0,0:3='void',<26>,1:0]
[@1,5:8='main',<27>,1:5]
[@2,9:9='(',<8>,1:9]
[@3,10:10=')',<9>,1:10]
[@4,12:12='{',<6>,2:0]
[@5,18:22='const',<13>,3:4]
[@6,24:24='k',<27>,3:10]
[@7,26:26='=',<3>,3:12]
[@8,28:29='10',<28>,3:14]
[@9,30:30=';',<2>,3:16]
[@10,36:38='int',<25>,4:4]
[@11,40:40='i',<27>,4:8]
[@12,42:42='=',<3>,4:10]
[@13,44:44='1',<28>,4:12]
[@14,50:51='if',<10>,5:4]
[@15,53:53='j',<27>,5:7]
[@16,54:55='!=',<15>,5:8]
[@17,56:56='i',<27>,5:10]
[@18,66:66='j',<27>,6:8]
[@19,68:68='=',<3>,6:10]
[@20,70:70='i',<27>,6:12]
[@21,72:72='+',<20>,6:14]
[@22,74:74='1',<28>,6:16]
[@23,80:83='else',<11>,7:4]
[@24,85:86='if',<10>,7:9]
[@25,88:88='j',<27>,7:12]
[@26,90:91='==',<14>,7:14]
[@27,93:93='i',<27>,7:17]
[@28,103:103='i',<27>,8:8]
[@29,105:105='-',<21>,8:10]
[@30,107:107='1',<28>,8:12]
[@31,113:117='while',<12>,9:4]
[@32,119:119='j',<27>,9:10]
[@33,121:121='<',<16>,9:12]
[@34,123:123='5',<28>,9:14]
[@35,134:134='i',<27>,10:8]
[@36,136:136='*',<22>,10:10]
[@37,138:138='5',<28>,10:12]
[@38,148:148='i',<27>,11:8]
[@39,150:150='%',<24>,11:10]
[@40,152:153='10',<28>,11:12]
[@41,160:163='_hex',<27>,12:5]
[@42,165:165='=',<3>,12:10]
[@43,167:170='0x12',<28>,12:12]
[@44,172:172='}',<7>,13:0]
[@45,173:172='<EOF>',<-1>,13:1]
```

可以看到关键字和标识符都区分了开来。

test2.c1:

```c
int /*
//hello
\
*/
i = 1;
int j = // \
; \
; \
； \
;
3 ;
i//
int j;
/* com
* men
* t
*/
/**/
```

测试结果：

```sh
[@0,0:2='int',<25>,1:0]
[@1,20:20='i',<27>,5:0]
[@2,22:22='=',<3>,5:2]
[@3,24:24='1',<28>,5:4]
[@4,25:25=';',<2>,5:5]
[@5,27:29='int',<25>,6:0]
[@6,31:31='j',<27>,6:4]
[@7,33:33='=',<3>,6:6]
[@8,54:54='3',<28>,11:0]
[@9,56:56=';',<2>,11:2]
[@10,58:58='i',<27>,12:0]
[@11,62:64='int',<25>,13:0]
[@12,66:66='j',<27>,13:4]
[@13,67:67=';',<2>,13:5]
[@14,93:92='<EOF>',<-1>,18:4]
```

可以看到，所有的注释都没有识别出来。

test3.c1:

```c
/* abcdefg */
not_comment
*/

// \ comment
not_comment
```

测试结果：

```sh
[@0,14:24='not_comment',<27>,2:0]
[@1,26:26='*',<22>,3:0]
[@2,27:27='/',<23>,3:1]
[@3,43:53='not_comment',<27>,6:0]
[@4,56:55='<EOF>',<-1>,8:0]
```

可以看到，两个非注释都识别出来。